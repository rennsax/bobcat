includefile(include/header)

COMMENT(manpage, section, releasedate, archive, short name)
manpage(FBB::Field)(3bobcat)(_CurYrs_)(libbobcat-dev__CurVers_-x.tar.gz)
                    (Number fields)

manpagename(FBB::Field)(sets and retrieves position based number fields)

manpagesynopsis()
    bf(#include <bobcat/field>)nl()

manpagedescription()

Numbers may contain position-based sub-fields. E.g., a value like 12345
might consist of fields 12 and 345. Such fields are position based, using end-
and begin offsets in the number representations. In this example 345 begins at
digit position 0 (indicating the least significant digit of 12345) and at
digit position 3 the next field starts. Likewise, the field 12 begins at digit
position 3 and has ended at digit position 5. 

The tt(Field) class template provides facilities for retrieving and assigning
position based values of existing numeric values of (currently) at most 64
bits. 

To represent such fields the following format is used:
        verb(
    Field<base, end, begin>::function(argument(s))
        )
    where tt(base) specifies the number system's base value, tt(end) specifies
the (0-based) index position where the number field ends, and tt(begin)
specifies the index position where the number field begins. 
        verb(
    Field10<3, 0>::get(12345)    // returns 345
    Field10<5, 3>::get(12345)    // returns  12
        )

Corresponding to the standard way of indicating digit positions in numbers,
the left-hand side digit position is specified first, and the right-hand side
digit position is specified next. Fields can be retrieved, but they can also
be set: to set a field's value the following format could be used:
        verb(
    Field10<3, 1>::set(12345, 99)   // returns 12995
    Field10<1, 0>::set(12345, 0)    // returns 12450
        )

The class template tt(Field10) interprets positions as positions in decimal
numbers. The class template tt(Field2) uses binary number representations, and
the generic tt(Field<base, end, begin>) class template can be used to indicate
fields using other number bases. E.g.,
        verb(
    Field<16, 1, 0>::set(0xdeaf, 0xd) 
        )
    returns the hexadecimal value tt(0xdead'). 

The class templates themselves are unaware of bases of number systems. Since
0xdeaf equals the decimal value 57007 and 0xd equals 13, calling the above
function as
        verb(
    Field<16, 1, 0>::set(76007, 13) 
        )
    also returns the hexadecimal value tt(0xdead'). 

The generic tt(Field) class template requires three non-type parameters:
    itemization(
    itt(base), specifying the base of the number system;
    itt(end), specifying the 0-based offset of the digit position where the
        field has ended;
    itt(begin), specifying the 0-based offset of the digit position where the
        field begins;
    )

To further illustrate the elements of a field in a number consider the
following subdivision of a number tt(value):
        verb(
    |   C   |   B   |   A   |
    -------------------------
           ^       ^       ^
           end     begin   0
        )
    In general, a value consists of the fields A, B and C. B begins at digit
offset tt(begin) and its most significant digit is at digit offset tt(end -
1). 

Using tt(pow(exp)) to represent tt(pow(base, exp)), where tt(base) is the
specified number system's base value, then the fields A, B, and C,
are obtained as follows:
        verb(
    A:  value % pow(begin)              // remove values from 'begin' and up

    B:  value % pow(end)   / pow(begin) // remove beyond 'end', then 
                                        // cut off values below 'begin'

    C:  value / pow(end)                // cut off values below 'end'
        )
    These are the mere A, B and C values. Those value can be replaced by other
values: 

        verb(
    replace A:  value - value % pow(begin)  // add to plain A 
                + X % pow(begin)            // X's value not exceeding 'begin'

    replace B:  value - value % pow(end) / pow(begin) * pow(begin)
                       + X % pow(end - begin) * pow(begin)
    ->

    replace B:  value (
                        X % pow(end - begin) -
                        value % pow(end) / pow(begin)
                      )
                      * pow(begin)


    replace C:  value / pow(end) + X * pow(end)
        )

If base 2 is used bit shifts can be used:

To access the values of the fields:
        verb(
    A:  value & ((1 << begin) - 1)
    B:  value >> (1 >> begin) & (1 << (end - begin) - 1)
    C:  value >> (1 >> end)
        )

    To replace these values use:

        verb(
    replace A:  value & ~((1 << begin) - 1) | X & ~((1 << begin) - 1)

    replace B:  (value & 
                    (~( (1 << (end - begin)) - 1) << begin )) 
                |
                    ((X & ((1 << (end - begin) - 1))) << begin);

    replace C:  (value >> end << end) 
                |
                (
                    ((X & (
                            (1 << (end - begin) - 1))
                      )
                    ) 
                    << end
                );
        )


includefile(include/namespace)

manpagesection(INHERITS FROM)
    The specialized classes tt(Field2) and tt(Field10) are derived from tt(the
generic class template tt(Field). 


manpagesection(CONSTRUCTORS)
    itemization(
    itb(Field())
    )

    Copy and move constructors (and assignment operators) are not available.

manpagesection(OVERLOADED OPERATORS)
    itemization(
    itb()
    )

manpagesection(MEMBER FUNCTIONS)
     All members of bf(std::ostringstream) and bf(  std::exception) are
available, as bf(FBB::Field) inherits from these classes.
    itemization(
    itb()
    )

manpagesection(MANIPULATORS)
    itemization(
    itb(FBB::) 
    )

manpagesection(EXAMPLE)
    To do

manpagefiles()
    em(bobcat/field) - defines the class interface

manpageseealso()
    bf(bobcat)(7)

manpagebugs()
    None Reported.

includefile(include/trailer)
